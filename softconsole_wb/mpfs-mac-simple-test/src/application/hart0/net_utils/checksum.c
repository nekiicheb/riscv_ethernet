#include "checksum.h"
#include "netinet_in.h"
#include <assert.h>
#include <string.h>

#define L2_ENABLE
#ifdef CHECKSUM_TEST
const uint8_t correct_ping_packet[98] =
{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00,
		0x00, 0x54, 0xf3, 0x69, 0x40, 0x00, 0x40, 0x01, 0x49, 0x3d, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00,
		0x00, 0x01, 0x08, 0x00, 0x4c, 0xee, 0x10, 0x79, 0x00, 0x01, 0x6d, 0xa8, 0x66, 0x63, 0x00, 0x00,
		0x00, 0x00, 0x06, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
		0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
		0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
		0x36, 0x37
};

const uint8_t incorrect_ping_packet[98] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x54, 0xf0, 0x69, 0x40, 0x00, 0x40, 0x01, 0x49, 0x3d, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00,
    0x00, 0x01, 0x08, 0x00, 0x4c, 0xee, 0x10, 0x79, 0x00, 0x01, 0x6d, 0xa8, 0x66, 0x63, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
    0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37
};
#endif

#define MIN_PACKET_SIZE 60
#define IP4TYPE 0x800
#define L2_SIZE 14
#define IP_HEADER_SIZE 20
#define IP_CRC_MSB_OFFSET 10
#define IP_CRC_LSB_OFFSET 11

static uint32_t sum(uint16_t *data, int size, uint32_t origsum)
{
	while (size > 1)
	{
		origsum += *data++;
		size -= 2;
	}
	if (size)
		origsum += ntohs(((*(uint8_t *)data) & 0xff) << 8);
	return origsum;
}

static uint16_t checksum(uint16_t *data, int size, uint16_t origsum)
{
	origsum = sum(data, size, origsum);
	origsum = (origsum & 0xffff) + (origsum >> 16);
	origsum = (origsum & 0xffff) + (origsum >> 16);
	return (~origsum & 0xffff);
}

uint16_t get_ip_chksum(uint8_t *data, int size)
{
	return checksum(data, size, 0);
}

bool check_ip_crc(uint8_t* buf, size_t len)
{
  uint8_t* ptr = buf;
  #ifdef L2_ENABLE
	if(len < MIN_PACKET_SIZE)
	{
		//ethernet пакет не может быть меньше 60 байт
		return false;
	}
	ptr = ptr + 12;
	uint16_t eth_type = ntohs(*((uint16_t*)ptr));
	if(eth_type != IP4TYPE)
	{
		// в тз не расписан этот вариант, отбросим пакет
		return false;
	}
	ptr = ptr + 2;
  #endif
	uint16_t crc_from_packet = ntohs(*((uint16_t*)(ptr + IP_CRC_MSB_OFFSET)));
	(*((uint16_t*)(ptr + IP_CRC_MSB_OFFSET))) = 0;
	uint16_t calc_crc = ntohs(get_ip_chksum(ptr, IP_HEADER_SIZE));
	(*((uint16_t*)(ptr + IP_CRC_MSB_OFFSET))) = htons(crc_from_packet);
	return (calc_crc == crc_from_packet);
}

#ifdef CHECKSUM_TEST
uint8_t pkt[(sizeof(correct_ping_packet))];
void test_checksum()
{
  // test with correct pkt
  memcpy(&pkt[0], &correct_ping_packet[0], sizeof(pkt));
  assert(check_ip_crc(&pkt[0], sizeof(pkt)) == true);
  // test src pkt correct
  if(memcmp(&pkt[0], &correct_ping_packet[0], sizeof(correct_ping_packet)) != 0)
  {
    assert("src packet spoiled");
    return;
  }
  // test with correct pkt
  memcpy(&pkt[0], &incorrect_ping_packet[0], sizeof(pkt));
  assert(check_ip_crc(&pkt[0], sizeof(pkt)) == false);
}
#endif
