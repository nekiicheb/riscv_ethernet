#include "proprietary_pkt_util.h"
#include "crc32.h"
#include "netinet_in.h"
#include <assert.h>
#include <string.h>

#define L2_ENABLE
#ifdef CHECKSUM_TEST
const uint8_t correct_ping_packet[102] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x54, 0xf3, 0x69, 0x40, 0x00, 0x40, 0x01, 0x49, 0x3d, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00,
    0x00, 0x01, 0x08, 0x00, 0x4c, 0xee, 0x10, 0x79, 0x00, 0x01, 0x6d, 0xa8, 0x66, 0x63, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
    0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x53, 0xf4, 0x82, 0x02
};

const uint8_t incorrect_ping_packet[102] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x54, 0xf3, 0x69, 0x40, 0x00, 0x40, 0x01, 0x49, 0x3d, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00,
    0x00, 0x01, 0x08, 0x00, 0x4c, 0xee, 0x10, 0x79, 0x00, 0x01, 0x6d, 0xa8, 0x66, 0x63, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
    0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x53, 0xf4, 0x82, 0x01
};
#endif

#define MIN_PACKET_SIZE 60
#define IP4TYPE 0x800
#define L2_SIZE 14
#define IP_HEADER_SIZE 20
#define CRC32_SIZE 4

bool check_proprietary_crc(const uint8_t* buf, size_t len)
{
  const uint8_t* ptr = buf;
  #ifdef L2_ENABLE
  if(len < MIN_PACKET_SIZE)
  {
    //ethernet пакет не может быть меньше 60 байт
    return false;
  }
  ptr = ptr + 12;
  uint16_t eth_type = ntohs(*((uint16_t*)ptr));
  if(eth_type != IP4TYPE)
  {
    // в тз не расписан этот вариант, отбросим пакет
    return false;
  }
  ptr = ptr + 2;
  #endif

  uint32_t calc_crc = htonl(xcrc32 (ptr, len - L2_SIZE - CRC32_SIZE, 0xffffffff));
  uint32_t crc_from_packet = htonl(*((uint32_t*)(ptr + len - L2_SIZE - CRC32_SIZE)));

  return (calc_crc == crc_from_packet);
}

uint32_t get_prop_pkt_crc(const uint8_t *data, size_t len)
{
  return htonl(xcrc32 (data, len, 0xffffffff));
}

#ifdef CHECKSUM_TEST
void test_checksum()
{
  // test with correct pkt
  assert(check_proprietary_crc(&correct_ping_packet[0], sizeof(correct_ping_packet)) == true);
  // test with incorrect pkt
  assert(check_proprietary_crc(&incorrect_ping_packet[0], sizeof(incorrect_ping_packet)) == false);
}
#endif
